#!/usr/bin/python


# Testrunner

# Goal is to be implemented in a single file - /usr/bin/testrunner - *not*
# a ton of site-packaged files, configuration files, and UI.

# Additional goal is to require minimal dependencies - this has been tested
# against system python from a 'minimal install' of rhel7
# Thus python3 and requests aren't available.  Le sigh.

import os
import tempfile
import uuid
import time
import subprocess
import urllib2

# temp for testing.  get from args
VERBOSITY = 4


################
# CONFIG
trserver = 'http://localhost:8400'
################

################


def dprint(v, *s):
    if v <= VERBOSITY:
        pfx = '#debug'+str(v)
        for i in xrange(v):
            pfx += '#'
        print pfx, s


def geturl_f(url, outf):
    """Retrieve URL and store to file"""
    dprint(4, 'geturl_f', url, outf)
    try:
        urlh = urllib2.urlopen(url)
        with open(outf, 'wb') as f:
            f.write(urlh.read())
        result = True
    except urllib2.HTTPError, e:
        dprint(3, 'geturl_s HTTP error', e.code, url)
        result = False
    except urllib2.URLError, e:
        dprint(3, 'geturl_s URL error', e.reason, url)
        result = False

    return result


def geturl_s(url):
    """Retrieve URL, return contents as list of lines
       Comment lines and blanks excluded"""
    dprint(4, 'geturl_s', url)
    try:
        result = []
        urlh = urllib2.urlopen(url)
        for line in urlh.readlines():
            ln = line.strip()
            if ln.startswith('#') or not ln:
                continue
            result.append(ln)
    except urllib2.HTTPError, e:
        dprint(3, 'geturl_s HTTP error', e.code, url)
        result = False
    except urllib2.URLError, e:
        dprint(3, 'geturl_s URL error', e.reason, url)
        result = False

    return result


def getstrategy(stname, visited=None, retval=None):
    """Get a strategy.
    Takes a strategy name (<owner>/<strategy>), retrieves it
    from the trserver.
    Returns a list of tuples (pri, test, args)
    """
    dprint(2, 'getstrategy', stname)
    dprint(3, 'getstrategy', stname, visited, retval)
    if visited is None:
        visited = []
    if retval is None:
        retval = []
    if stname in visited:
        dprint(0, 'loop detected', stname, visited)
        # resilient but dangerous; keeps going
        return retval
    visited.append(stname)

    sto, sts = stname.split('/')
    surl = os.path.join(trserver, sto, 'strategy', sts)
    outp = geturl_s(surl)
    if not outp:
        dprint(0, 'failed strategy', stname)
        # resilient but dangerous; keeps going
        return retval
    for ln in outp:
        cmdln = ln.split()
        cmd = cmdln.pop(0)
        if cmd == 'test':
            pri = 50
            if cmdln[0].startswith('pri='):
                pric = cmdln.pop(0)
                pri = int(pric.split('=')[1])
            test = cmdln.pop(0)
            retval.append((pri, test, cmdln))
            dprint(3,  'added test',  pri, test, cmdln)
        elif cmd == 'include' or cmd == 'strategy':
            dprint(3,  'including strategy', cmdln)
            retval = getstrategy(cmdln.pop(0), visited, retval)
        else:
            dprint(0,  'error unknown cmd', cmd)

    return retval


def tests_in(strategy):
    """Return a list of tests from a strategy list"""
    retval = set()
    for pri, test, args in strategy:
        retval.add(test)
    return list(retval)


def get_test(rootdir, tname):
    """get a test payload into rootdir"""
    to, ts = tname.split('/')
    dprint(2, 'get test', tname)
    tbaseurl = os.path.join(trserver, to, 'tests', ts)
    tidxurl = os.path.join(tbaseurl, '.tr.idx')
    tlocaldr = os.path.join(rootdir, to, ts)
    outp = geturl_s(tidxurl)
    if not outp:
        dprint(0,  'failed get test', tname)
        return False
    os.makedirs(tlocaldr,  0700)
    for ln in outp:
        itype, name, mode = ln.split('|')
        if itype == "DIR":
            dstd = os.path.join(tlocaldr, name)
            dprint(3, 'get_test mkdir', dstd, mode)
            intmode = int(mode, 8)
            os.mkdir(dstd, intmode)
        elif itype == "FILE":
            srcu = os.path.join(tbaseurl, name)
            dstf = os.path.join(tlocaldr, name)
            intmode = int(mode, 8)
            dprint(3, 'get_test retrieve', srcu, dstf, mode)
            if geturl_f(srcu, dstf):
                os.chmod(dstf, intmode)


def run_test(rd, test, args):
    """Run a test at rd/test"""
    execdir = os.path.join(rd, test)
    backto = os.getcwd()
    os.chdir(execdir)
    execf = None
    for f in os.listdir(execdir):
        fn, fx = os.path.splitext(f)
        if fn.endswith('runme'):
            execf = f
            break
    if not execf:
        dprint(0, 'no exec', test)
        return None, None, None
    pocmd = []
    pocmd.append(os.path.join('.', execf))
    pocmd.extend(args)
    dprint(2, 'run_test_exec', execdir, pocmd)
    proc = subprocess.Popen(pocmd, stderr=subprocess.PIPE,
                            stdout=subprocess.PIPE)
    (out, err) = proc.communicate()
    ret = proc.returncode
    os.chdir(backto)
    return ret, out, err
################

# TODO arg parsing here
# the positional args are all strategy names
# the only options should be:
# . changing trserver from default
# . dry-run (don't run tests)
# . drier-run (don't even dl tests)
# . changing result submit location / method
# . a oneshot "just run one test" mode


slist = getstrategy('team1/demo')

# This should sort by pri but preserve order otherwise
slist.sort(key=lambda tup: tup[0])

tmpdir = tempfile.mkdtemp(prefix='testrunner-')
dprint(2, 'running in', tmpdir)

for test in tests_in(slist):
    get_test(tmpdir, test)

# This is unique per RFC4122
resultid = uuid.uuid1().hex
print "Running testrunner job", resultid
outfn = os.path.join(tmpdir, 'testrunner-'+resultid+'.result')
FH = open(outfn, 'w')

for pri, test, args in slist:
    now = int(time.mktime(time.gmtime()))
    msg = '#TR#{} {} {}\n'.format(now, 'START', (test, args))
    dprint(2, msg)
    FH.write(msg)
    res, stdo, stde = run_test(tmpdir, test, args)
    now = int(time.mktime(time.gmtime()))
    msg = '#TR#{} {} {}\n'.format(now, 'RES:'+str(res), (test, args))
    dprint(2, msg)
    FH.write(msg)
    #TODO print stdout stderr

FH.close()

#TODO submit results to trserver
#TODO clean up tmpdir
